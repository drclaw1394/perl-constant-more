=head1 NAME

constant::more - Define constants from the command line

=head1 SYNOPSIS

Can use as a direct alternative to C<use constant>:

	use constant::more PI    => 4 * atan2(1, 1);
	use constant:more DEBUG => 0;

	print "Pi equals ", PI, "...\n" if DEBUG;

	use constant::more {
	    SEC   => 0,
	    MIN   => 1,
	    HOUR  => 2,
	    MDAY  => 3,
	    MON   => 4,
	    YEAR  => 5,
	    WDAY  => 6,
	    YDAY  => 7,
	    ISDST => 8,
	};


Parse arguments using L<Getopt::Long> and environment variables to set values
to constants declared in your code

	# ###
	# example.pl

	use constant::more {
		FEATURE_A_ENABLED=>{		#Name of the constant
			val=>0,		#default value 
			opt=>"feature1",	#Getopt::Long option specification
			env=>"MY_APP_FEATURE_A"	#Environment variable copy value from 
		},

		FEATURE_B_CONFIG=>{
			val=>"disabled",
			opt=>"feature2=s",	#Getopt::Long format
		}
	};

	
	if(FEATURE_A_ENABLED){
		#Do interesting things here
		print "Feature a is enabled
	}
	
	print "Feature b config is: ".FEATURE_B_CONFIG."\n";

	__END__

	#######

	# From command line
	perl example.pl --feature1  --feature2=active
	

	# ####
	# output

	Feature a is enabled
	Feature b config is: active
	


=head1 DESCRIPTION

Performs the similar tasks as C<use constant>, but adds the facility to set
the value of constants with values from the command line or environment
variables.



=head1 MOTIVATION

I use the C<constant> and C<enum> pragma alot for unchanging values in my code.
However, I would like to have the flexibility to configure constants at program
start to enable debuging for example.

It is quite common to see something like this:

	package My::Complex::Package

	use constant DEBUG=>$ENV{"my_complex_package_debug"}//0;

	if(DEBUG){
		warn "debugging";
	}

This enables debug code using an evironment variable. This module implements a
similar idea but can process command line options using L<GetOpt::Long>


=head1 USAGE

=head2 Simple Form

In its simplest form, defining an constant is just like the C<use constant> pragma:

	use constant::more NAME=>"value";	#Set a single constant
		
	use constant::more {			#Set multiple constants
			NAME=>"value",
			ANOTHER=>"one",
	};

=head2 Normal Form

In its full form, an annonyous hash containing keys C<val>, C<opt>, C<env> and
C<sub> are used to setup the processing of a constant:

	use constant::more {
		MY_NAME=>{
			val=>"john",
			opt=>"name=s",
			env=>"ENV_VAR_NAME",
		},
		ANOTHER=>{
			value=>"one",
		}
	};


The general form of usage is showin in the Disccusion section. However here are the fine details

Constants are defined in callers name space unless name includes a package in the name
A name with '::' in it is classed as a full name for a variable. Use this to
declare constants in a common namespace (ie CONFIG for example)

Constants are only defined/set if they don't exist already.This makes
configuring constants in sub moudles possible. The module can specify a default
value, if it hasn't been been defined by the top level application. This is why
it is important to C<use constant::more> at the start of your file.


Precedence of constant value is code, envrionment then command option

This means the value (default) specified in code will be only used if no
environment variable or command option is applicable.

If a command option is provided and a environment variable is available, the
command option will be used


=head2 Advanced Form


If the child, annonymous hash contains CODE reference in the field C<sub>, top level keys in the hash are only used as labels and not as a constant name.
The actual constant names and values to be generated are returned as a key value list from the CODE ref. 

The CODE ref is called with a key value pair. The first input argument is the
name of the command line option, or undef if default or environment variable.
The second argument is the value from the command line option, default or
environment variable.

	use constant::more {
		MY_NAME=>{
			val=>"john",
			opt=>"name=s",
			env=>"ENV_VAR_NAME",
			sub=>sub{
				my ($key,$value)=@_;
				state $i=0;
				$i++;
			
			}
		},
	};

The code ref may be called multiple times if command line processing is enabled
(with the C<opt> field). The names and values returned can be different each
time for advanced use cases.





=head1 BUGS

=head1 REPOSITORY

=head1 LICENSE

=head1 AUTHOR

=head1 RELATED MODULES

L<Getopt::constant>

=head1 COPYRIGHT


